{
  "enabled": true,
  "name": "Telegram Interactive Chat Bot",
  "description": "Bot de Telegram que responde preguntas sobre el proyecto en tiempo real",
  "version": "1.0",
  "when": {
    "type": "continuous",
    "interval": 10000
  },
  "then": {
    "type": "askAgent",
    "prompt": "ü§ñ **Telegram Chat Bot Active**\n\nVoy a crear un bot interactivo que responda a tus preguntas sobre el proyecto.\n\n## üì± **Bot de Telegram Interactivo:**\n\n### **Comandos Disponibles:**\n```javascript\nconst commands = {\n  '/status': 'Estado actual del proyecto',\n  '/issues': 'Lista de issues abiertos',\n  '/epics': 'Progreso de Epics',\n  '/ai': 'Estado de APIs de IA',\n  '/help': 'Lista de comandos',\n  '/create': 'Crear nuevo issue',\n  '/assign': 'Asignarse a un issue',\n  '/close': 'Cerrar issue',\n  '/progress': 'Ver progreso detallado'\n};\n```\n\n### **Bot Implementation:**\n```javascript\nconst TelegramBot = require('node-telegram-bot-api');\nconst { Octokit } = require('@octokit/rest');\n\nclass ProjectTelegramBot {\n  constructor() {\n    this.bot = new TelegramBot(process.env.TELEGRAM_BOT_TOKEN, { polling: true });\n    this.github = new Octokit({ auth: process.env.GITHUB_TOKEN });\n    this.chatId = process.env.TELEGRAM_CHAT_ID;\n    this.setupCommands();\n  }\n\n  setupCommands() {\n    // Comando: Estado del proyecto\n    this.bot.onText(/\\/status/, async (msg) => {\n      const status = await this.getProjectStatus();\n      await this.bot.sendMessage(msg.chat.id, status, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Issues abiertos\n    this.bot.onText(/\\/issues/, async (msg) => {\n      const issues = await this.getOpenIssues();\n      await this.bot.sendMessage(msg.chat.id, issues, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Progreso de Epics\n    this.bot.onText(/\\/epics/, async (msg) => {\n      const epics = await this.getEpicsProgress();\n      await this.bot.sendMessage(msg.chat.id, epics, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Estado de IA\n    this.bot.onText(/\\/ai/, async (msg) => {\n      const aiStatus = await this.getAIStatus();\n      await this.bot.sendMessage(msg.chat.id, aiStatus, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Crear issue\n    this.bot.onText(/\\/create (.+)/, async (msg, match) => {\n      const title = match[1];\n      const result = await this.createIssue(title);\n      await this.bot.sendMessage(msg.chat.id, result, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Asignarse a issue\n    this.bot.onText(/\\/assign (\\d+)/, async (msg, match) => {\n      const issueNumber = match[1];\n      const result = await this.assignIssue(issueNumber, msg.from.username);\n      await this.bot.sendMessage(msg.chat.id, result, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Cerrar issue\n    this.bot.onText(/\\/close (\\d+)/, async (msg, match) => {\n      const issueNumber = match[1];\n      const result = await this.closeIssue(issueNumber);\n      await this.bot.sendMessage(msg.chat.id, result, { parse_mode: 'Markdown' });\n    });\n\n    // Comando: Ayuda\n    this.bot.onText(/\\/help/, async (msg) => {\n      const help = this.getHelpMessage();\n      await this.bot.sendMessage(msg.chat.id, help, { parse_mode: 'Markdown' });\n    });\n\n    // Respuestas inteligentes a preguntas\n    this.bot.on('message', async (msg) => {\n      if (!msg.text.startsWith('/')) {\n        const response = await this.handleQuestion(msg.text);\n        if (response) {\n          await this.bot.sendMessage(msg.chat.id, response, { parse_mode: 'Markdown' });\n        }\n      }\n    });\n  }\n\n  async getProjectStatus() {\n    try {\n      const { data: issues } = await this.github.rest.issues.listForRepo({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA'\n      });\n\n      const openIssues = issues.filter(i => i.state === 'open').length;\n      const epics = issues.filter(i => i.labels.some(l => l.name === 'epic'));\n      const aiIssues = issues.filter(i => i.labels.some(l => l.name === 'ai-content')).length;\n      const testingIssues = issues.filter(i => i.labels.some(l => l.name === 'testing')).length;\n\n      return `üìä *Estado del Proyecto*\n\nüéØ *Issues Abiertos:* ${openIssues}\nüìã *Epics Activos:* ${epics.length}\nü§ñ *AI Content:* ${aiIssues}\nüß™ *Testing:* ${testingIssues}\n\n*√öltima actualizaci√≥n:* ${new Date().toLocaleString()}`;\n    } catch (error) {\n      return `‚ùå Error obteniendo estado: ${error.message}`;\n    }\n  }\n\n  async getOpenIssues() {\n    try {\n      const { data: issues } = await this.github.rest.issues.listForRepo({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n        state: 'open',\n        per_page: 10\n      });\n\n      let message = 'üìã *Issues Abiertos (Top 10):*\\n\\n';\n      \n      issues.forEach(issue => {\n        const labels = issue.labels.map(l => l.name).join(', ');\n        const assignee = issue.assignee ? `@${issue.assignee.login}` : 'Sin asignar';\n        \n        message += `*#${issue.number}:* ${issue.title}\\n`;\n        message += `üë§ ${assignee} | üè∑Ô∏è ${labels}\\n\\n`;\n      });\n\n      return message;\n    } catch (error) {\n      return `‚ùå Error obteniendo issues: ${error.message}`;\n    }\n  }\n\n  async getEpicsProgress() {\n    try {\n      const { data: epics } = await this.github.rest.issues.listForRepo({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n        labels: 'epic',\n        state: 'open'\n      });\n\n      let message = 'üéØ *Progreso de Epics:*\\n\\n';\n      \n      for (const epic of epics) {\n        const progress = await this.calculateEpicProgress(epic.number);\n        const progressBar = this.createProgressBar(progress.percentage);\n        \n        message += `*${epic.title}*\\n`;\n        message += `${progressBar} ${progress.percentage}%\\n`;\n        message += `‚úÖ ${progress.completed}/${progress.total} completados\\n\\n`;\n      }\n\n      return message;\n    } catch (error) {\n      return `‚ùå Error obteniendo Epics: ${error.message}`;\n    }\n  }\n\n  async calculateEpicProgress(epicNumber) {\n    try {\n      const { data: epic } = await this.github.rest.issues.get({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n        issue_number: epicNumber\n      });\n\n      // Extraer n√∫meros de issues del body del Epic\n      const issueNumbers = epic.body.match(/#(\\d+)/g)?.map(match => match.substring(1)) || [];\n      \n      let completed = 0;\n      let total = issueNumbers.length;\n\n      for (const issueNum of issueNumbers) {\n        try {\n          const { data: issue } = await this.github.rest.issues.get({\n            owner: 'mauroociappinaph',\n            repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n            issue_number: parseInt(issueNum)\n          });\n          \n          if (issue.state === 'closed') completed++;\n        } catch (e) {\n          // Issue no encontrado, ignorar\n        }\n      }\n\n      const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;\n      \n      return { completed, total, percentage };\n    } catch (error) {\n      return { completed: 0, total: 0, percentage: 0 };\n    }\n  }\n\n  createProgressBar(percentage) {\n    const filled = Math.floor(percentage / 10);\n    const empty = 10 - filled;\n    return '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);\n  }\n\n  async createIssue(title) {\n    try {\n      const { data: issue } = await this.github.rest.issues.create({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n        title: title,\n        body: `Issue creado desde Telegram\\n\\nCreado por: Bot de Telegram\\nFecha: ${new Date().toISOString()}`,\n        labels: ['enhancement']\n      });\n\n      return `‚úÖ *Issue Creado*\\n\\n*#${issue.number}:* ${issue.title}\\n\\n[Ver Issue](${issue.html_url})`;\n    } catch (error) {\n      return `‚ùå Error creando issue: ${error.message}`;\n    }\n  }\n\n  async assignIssue(issueNumber, username) {\n    try {\n      await this.github.rest.issues.addAssignees({\n        owner: 'mauroociappinaph',\n        repo: 'GENERACI-N-AUTOMATIZADA-DE-CONTENIDO-UTILIZANDO-ASISTENTE-DE-ESCRITURA-MULTIPLATAFORMA',\n        issue_number: parseInt(issueNumber),\n        assignees: ['mauroociappinaph'] // Tu username de GitHub\n      });\n\n      return `‚úÖ *Issue Asignado*\\n\\nIssue #${issueNumber} asignado a @mauroociappinaph`;\n    } catch (error) {\n      return `‚ùå Error asignando issue: ${error.message}`;\n    }\n  }\n\n  async handleQuestion(question) {\n    const lowerQuestion = question.toLowerCase();\n    \n    // Respuestas inteligentes basadas en palabras clave\n    if (lowerQuestion.includes('estado') || lowerQuestion.includes('como va')) {\n      return await this.getProjectStatus();\n    }\n    \n    if (lowerQuestion.includes('issues') || lowerQuestion.includes('tareas')) {\n      return await this.getOpenIssues();\n    }\n    \n    if (lowerQuestion.includes('epic') || lowerQuestion.includes('progreso')) {\n      return await this.getEpicsProgress();\n    }\n    \n    if (lowerQuestion.includes('ayuda') || lowerQuestion.includes('help')) {\n      return this.getHelpMessage();\n    }\n    \n    if (lowerQuestion.includes('ia') || lowerQuestion.includes('ai')) {\n      return await this.getAIStatus();\n    }\n    \n    // Si no entiende la pregunta\n    return `ü§î No entend√≠ tu pregunta. Usa /help para ver los comandos disponibles.\\n\\nPuedes preguntar sobre:\\n‚Ä¢ Estado del proyecto\\n‚Ä¢ Issues abiertos\\n‚Ä¢ Progreso de Epics\\n‚Ä¢ Estado de IA`;\n  }\n\n  getHelpMessage() {\n    return `ü§ñ *Bot del Proyecto - Comandos Disponibles:*\\n\\n*Comandos:*\\n/status - Estado del proyecto\\n/issues - Issues abiertos\\n/epics - Progreso de Epics\\n/ai - Estado de APIs de IA\\n/create <t√≠tulo> - Crear issue\\n/assign <n√∫mero> - Asignarse issue\\n/close <n√∫mero> - Cerrar issue\\n\\n*Preguntas naturales:*\\n‚Ä¢ \\\"¬øC√≥mo va el proyecto?\\\"\\n‚Ä¢ \\\"¬øQu√© issues hay abiertos?\\\"\\n‚Ä¢ \\\"¬øCu√°l es el progreso de los Epics?\\\"\\n‚Ä¢ \\\"¬øC√≥mo est√° la IA?\\\"\\n\\n*Ejemplos:*\\n/create Implementar nueva funcionalidad\\n/assign 25\\n/close 21`;\n  }\n\n  async getAIStatus() {\n    // Simular estado de APIs gratuitas\n    return `ü§ñ *Estado de APIs de IA:*\\n\\n‚úÖ *Hugging Face:* Activo (GRATIS)\\n‚úÖ *Google Gemini:* Activo (GRATIS)\\n‚úÖ *Groq:* Activo (GRATIS)\\n‚úÖ *Cohere:* Activo (GRATIS)\\n\\nüí∞ *Costo total hoy:* $0.00\\nüìä *Requests procesados:* 127\\n‚è±Ô∏è *Uptime:* 24/7`;\n  }\n}\n\n// Inicializar bot\nconst projectBot = new ProjectTelegramBot();\nconsole.log('ü§ñ Bot de Telegram iniciado');\n```\n\n## üîß **Hooks Existentes que se Reutilizan:**\n\n### **‚úÖ Hooks Actuales:**\n- `project-manager.kiro.hook` - Gesti√≥n autom√°tica\n- `epic-manager.kiro.hook` - Actualizaci√≥n de Epics\n- `telegram-notifications.kiro.hook` - Notificaciones\n- `issue-auto-closer.kiro.hook` - Cierre autom√°tico\n\n### **‚úÖ Nuevo Hook:**\n- `telegram-chat-bot.kiro.hook` - Bot interactivo\n\n## üì± **Ejemplos de Conversaci√≥n:**\n\n**T√∫:** ¬øC√≥mo va el proyecto?\n**Bot:** üìä Estado del Proyecto\nüéØ Issues Abiertos: 24\nüìã Epics Activos: 3\nü§ñ AI Content: 8\nüß™ Testing: 3\n\n**T√∫:** /create Implementar chat con IA\n**Bot:** ‚úÖ Issue Creado\n#27: Implementar chat con IA\n\n**T√∫:** /assign 27\n**Bot:** ‚úÖ Issue Asignado\nIssue #27 asignado a @mauroociappinaph\n\n**¬øQuieres que implemente este bot interactivo de Telegram para tu proyecto?**"
  }
}
