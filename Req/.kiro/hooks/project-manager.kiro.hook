{
  "enabled": true,
  "name": "Project Manager",
  "description": "Gestiona autom√°ticamente el proyecto: actualiza progress tracking, maneja epics, y coordina issues",
  "version": "1.0",
  "when": {
    "type": "onCommit",
    "conditions": {
      "skipMergeCommits": true,
      "skipWIPCommits": true,
      "minFilesChanged": 1
    }
  },
  "then": {
    "type": "askAgent",
    "prompt": "üéØ **Project Manager Activated**\n\nVoy a analizar el commit y actualizar autom√°ticamente el estado del proyecto.\n\n## üìä **An√°lisis Autom√°tico del Commit:**\n\n### **1. Detectar Issues Mencionados**\n```bash\necho \"üîç Analizando commit para gesti√≥n de proyecto...\"\n\n# Obtener mensaje del √∫ltimo commit\nCOMMIT_MSG=$(git log -1 --pretty=%B)\necho \"üìù Mensaje del commit: $COMMIT_MSG\"\n\n# Buscar referencias a issues con palabras clave\nFIXES_ISSUES=$(echo \"$COMMIT_MSG\" | grep -oE \"[Ff]ixes #[0-9]+\" | grep -oE \"[0-9]+\")\nCLOSES_ISSUES=$(echo \"$COMMIT_MSG\" | grep -oE \"[Cc]loses #[0-9]+\" | grep -oE \"[0-9]+\")\nRESOLVES_ISSUES=$(echo \"$COMMIT_MSG\" | grep -oE \"[Rr]esolves #[0-9]+\" | grep -oE \"[0-9]+\")\nREFS_ISSUES=$(echo \"$COMMIT_MSG\" | grep -oE \"#[0-9]+\" | grep -oE \"[0-9]+\")\n\necho \"üîó Issues a cerrar: $FIXES_ISSUES $CLOSES_ISSUES $RESOLVES_ISSUES\"\necho \"üîó Issues referenciados: $REFS_ISSUES\"\n```\n\n### **2. Verificar Estado de Tests y Build**\n```bash\necho \"üß™ Verificando estado del proyecto...\"\n\n# Ejecutar tests\ncd Req/backend\nTEST_RESULT=$(npm run test --silent 2>&1)\nTEST_EXIT_CODE=$?\n\nif [ $TEST_EXIT_CODE -eq 0 ]; then\n    echo \"‚úÖ Tests pasando - Proyecto estable\"\n    PROJECT_STABLE=true\nelse\n    echo \"‚ùå Tests fallando - Proyecto inestable\"\n    PROJECT_STABLE=false\nfi\n\n# Verificar build del frontend\ncd ../frontend\nBUILD_RESULT=$(npm run build --silent 2>&1)\nBUILD_EXIT_CODE=$?\n\nif [ $BUILD_EXIT_CODE -eq 0 ]; then\n    echo \"‚úÖ Build exitoso - Frontend estable\"\n    FRONTEND_STABLE=true\nelse\n    echo \"‚ùå Build fallando - Frontend inestable\"\n    FRONTEND_STABLE=false\nfi\n```\n\n### **3. Analizar Archivos Modificados**\n```bash\necho \"üìÅ Categorizando cambios...\"\n\n# Obtener archivos modificados\nMODIFIED_FILES=$(git diff-tree --no-commit-id --name-only -r HEAD)\n\n# Categorizar por √°rea\nFRONTEND_CHANGES=$(echo \"$MODIFIED_FILES\" | grep -E \"frontend/|src/components/|src/pages/\" | wc -l)\nBACKEND_CHANGES=$(echo \"$MODIFIED_FILES\" | grep -E \"backend/|src/services/|src/controllers/\" | wc -l)\nDATABASE_CHANGES=$(echo \"$MODIFIED_FILES\" | grep -E \"prisma/|migrations/\" | wc -l)\nTEST_CHANGES=$(echo \"$MODIFIED_FILES\" | grep -E \"\\.test\\.|__tests__/\" | wc -l)\nDOCS_CHANGES=$(echo \"$MODIFIED_FILES\" | grep -E \"\\.md$|docs/\" | wc -l)\n\necho \"üìä Cambios por √°rea:\"\necho \"- Frontend: $FRONTEND_CHANGES archivos\"\necho \"- Backend: $BACKEND_CHANGES archivos\"\necho \"- Database: $DATABASE_CHANGES archivos\"\necho \"- Tests: $TEST_CHANGES archivos\"\necho \"- Docs: $DOCS_CHANGES archivos\"\n```\n\n## üéØ **Gesti√≥n Autom√°tica de Issues:**\n\n### **Estrategia 1: Cierre Autom√°tico por Palabras Clave**\n```bash\n# Cerrar issues mencionados expl√≠citamente\nfor issue_num in $FIXES_ISSUES $CLOSES_ISSUES $RESOLVES_ISSUES; do\n    if [ -n \"$issue_num\" ]; then\n        echo \"üîí Cerrando issue #$issue_num autom√°ticamente\"\n        \n        # Obtener informaci√≥n del issue\n        ISSUE_INFO=$(gh issue view $issue_num --json title,labels,body)\n        ISSUE_TITLE=$(echo \"$ISSUE_INFO\" | jq -r '.title')\n        ISSUE_LABELS=$(echo \"$ISSUE_INFO\" | jq -r '.labels[].name' | tr '\\n' ',')\n        \n        # Cerrar con comentario detallado\n        gh issue close $issue_num --comment \"‚úÖ **Resuelto autom√°ticamente**\n        \n**Commit:** $(git rev-parse --short HEAD)\n**Mensaje:** $(echo \"$COMMIT_MSG\" | head -1)\n\n**Cambios realizados:**\n$(echo \"$MODIFIED_FILES\" | sed 's/^/- /')\n\n**Estado del proyecto:**\n- Tests: $([ \"$PROJECT_STABLE\" = true ] && echo \"‚úÖ Pasando\" || echo \"‚ùå Fallando\")\n- Build: $([ \"$FRONTEND_STABLE\" = true ] && echo \"‚úÖ Exitoso\" || echo \"‚ùå Fallando\")\n\n*Cerrado autom√°ticamente por Project Manager*\"\n        \n        # Actualizar Epic padre si existe\n        update_epic_progress $issue_num\n    fi\ndone\n```\n\n### **Estrategia 2: Actualizaci√≥n de Progress Tracking**\n```bash\n# Funci√≥n para actualizar Epic progress\nupdate_epic_progress() {\n    local closed_issue=$1\n    \n    # Buscar Epic padre\n    PARENT_EPIC=$(gh issue view $closed_issue --json body | jq -r '.body' | grep -oE \"Part of Epic: #[0-9]+\" | grep -oE \"[0-9]+\")\n    \n    if [ -n \"$PARENT_EPIC\" ]; then\n        echo \"üìã Actualizando Epic #$PARENT_EPIC\"\n        \n        # Obtener todos los sub-issues del Epic\n        EPIC_BODY=$(gh issue view $PARENT_EPIC --json body | jq -r '.body')\n        SUB_ISSUES=$(echo \"$EPIC_BODY\" | grep -oE \"#[0-9]+\" | grep -oE \"[0-9]+\" | grep -v \"$PARENT_EPIC\")\n        \n        # Contar estados\n        TOTAL_SUBS=0\n        COMPLETED_SUBS=0\n        IN_PROGRESS_SUBS=0\n        \n        for sub_issue in $SUB_ISSUES; do\n            SUB_STATE=$(gh issue view $sub_issue --json state | jq -r '.state')\n            SUB_ASSIGNEES=$(gh issue view $sub_issue --json assignees | jq -r '.assignees | length')\n            \n            TOTAL_SUBS=$((TOTAL_SUBS + 1))\n            \n            if [ \"$SUB_STATE\" = \"CLOSED\" ]; then\n                COMPLETED_SUBS=$((COMPLETED_SUBS + 1))\n            elif [ $SUB_ASSIGNEES -gt 0 ]; then\n                IN_PROGRESS_SUBS=$((IN_PROGRESS_SUBS + 1))\n            fi\n        done\n        \n        # Actualizar Epic con nuevo progress\n        UPDATED_BODY=$(echo \"$EPIC_BODY\" | sed -E \"s/Total Sub-Issues:\\*\\* [0-9]+/Total Sub-Issues:** $TOTAL_SUBS/g\")\n        UPDATED_BODY=$(echo \"$UPDATED_BODY\" | sed -E \"s/Completed:\\*\\* [0-9]+\\/[0-9]+/Completed:** $COMPLETED_SUBS\\/$TOTAL_SUBS/g\")\n        UPDATED_BODY=$(echo \"$UPDATED_BODY\" | sed -E \"s/In Progress:\\*\\* [0-9]+\\/[0-9]+/In Progress:** $IN_PROGRESS_SUBS\\/$TOTAL_SUBS/g\")\n        \n        gh issue edit $PARENT_EPIC --body \"$UPDATED_BODY\"\n        \n        # Si Epic est√° completo, cerrarlo tambi√©n\n        if [ $COMPLETED_SUBS -eq $TOTAL_SUBS ] && [ $TOTAL_SUBS -gt 0 ]; then\n            echo \"üéâ Epic #$PARENT_EPIC completado! Cerrando...\"\n            gh issue close $PARENT_EPIC --comment \"üéâ **Epic Completado**\n            \nTodos los sub-issues han sido completados:\n- Total: $TOTAL_SUBS\n- Completados: $COMPLETED_SUBS\n\n*Cerrado autom√°ticamente por Project Manager*\"\n        fi\n    fi\n}\n```\n\n### **Estrategia 3: Detecci√≥n Inteligente de Progreso**\n```bash\n# Detectar progreso por archivos modificados\necho \"ü§ñ Detectando progreso por contexto...\"\n\n# Obtener issues abiertos\nOPEN_ISSUES=$(gh issue list --state open --json number,title,body,labels)\n\n# Para cada archivo modificado, buscar issues relacionados\nfor file in $MODIFIED_FILES; do\n    echo \"üìÑ Analizando progreso en: $file\"\n    \n    # Buscar issues que mencionen este archivo\n    RELATED_ISSUES=$(echo \"$OPEN_ISSUES\" | jq -r \".[] | select(.body | contains(\\\"$file\\\")) | .number\")\n    \n    for issue_num in $RELATED_ISSUES; do\n        # Si tests pasan y archivo fue modificado, marcar progreso\n        if [ \"$PROJECT_STABLE\" = true ]; then\n            echo \"üìà Progreso detectado en issue #$issue_num\"\n            \n            gh issue comment $issue_num --body \"üìà **Progreso Detectado**\n            \n**Archivo modificado:** \\`$file\\`\n**Commit:** $(git rev-parse --short HEAD)\n**Tests:** ‚úÖ Pasando\n**Build:** $([ \"$FRONTEND_STABLE\" = true ] && echo \"‚úÖ Exitoso\" || echo \"‚ö†Ô∏è Verificar\")\n\n¬øEste cambio completa el issue? Si es as√≠, usa 'Closes #$issue_num' en el pr√≥ximo commit.\n\n*Detectado autom√°ticamente por Project Manager*\"\n        fi\n    done\ndone\n```\n\n## üìä **Gesti√≥n de Milestones y Releases**\n\n### **Auto-asignaci√≥n de Milestones**\n```bash\necho \"üéØ Gestionando milestones...\"\n\n# Crear milestones si no existen\ngh api repos/:owner/:repo/milestones --method POST --field title=\"Production Ready\" --field description=\"Issues cr√≠ticos para producci√≥n\" || true\ngh api repos/:owner/:repo/milestones --method POST --field title=\"AI Features\" --field description=\"Sistema de IA completo\" || true\ngh api repos/:owner/:repo/milestones --method POST --field title=\"Testing Complete\" --field description=\"Suite de testing completa\" || true\n\n# Auto-asignar issues a milestones basado en labels\nfor issue_num in $REFS_ISSUES; do\n    if [ -n \"$issue_num\" ]; then\n        ISSUE_LABELS=$(gh issue view $issue_num --json labels | jq -r '.labels[].name' | tr '\\n' ' ')\n        \n        if echo \"$ISSUE_LABELS\" | grep -q \"ai-content\"; then\n            gh issue edit $issue_num --milestone \"AI Features\"\n        elif echo \"$ISSUE_LABELS\" | grep -q \"testing\"; then\n            gh issue edit $issue_num --milestone \"Testing Complete\"\n        elif echo \"$ISSUE_LABELS\" | grep -q \"high-priority\"; then\n            gh issue edit $issue_num --milestone \"Production Ready\"\n        fi\n    fi\ndone\n```\n\n## üìà **Reporte de Estado del Proyecto**\n\n```bash\necho \"üìä Generando reporte de estado...\"\n\n# Contar issues por estado\nTOTAL_ISSUES=$(gh issue list --limit 1000 --json number | jq '. | length')\nOPEN_ISSUES=$(gh issue list --state open --limit 1000 --json number | jq '. | length')\nCLOSED_ISSUES=$(gh issue list --state closed --limit 1000 --json number | jq '. | length')\n\n# Contar por labels\nAI_ISSUES=$(gh issue list --label \"ai-content\" --limit 1000 --json number | jq '. | length')\nTESTING_ISSUES=$(gh issue list --label \"testing\" --limit 1000 --json number | jq '. | length')\nHIGH_PRIORITY=$(gh issue list --label \"high-priority\" --limit 1000 --json number | jq '. | length')\n\n# Calcular progreso\nif [ $TOTAL_ISSUES -gt 0 ]; then\n    PROGRESS_PERCENT=$((CLOSED_ISSUES * 100 / TOTAL_ISSUES))\nelse\n    PROGRESS_PERCENT=0\nfi\n\necho \"üìä **Project Status Report**\n\nüéØ **Overall Progress:** $PROGRESS_PERCENT% ($CLOSED_ISSUES/$TOTAL_ISSUES)\n\nüìã **Issues by Category:**\n- ü§ñ AI Content: $AI_ISSUES issues\n- üß™ Testing: $TESTING_ISSUES issues  \n- üî• High Priority: $HIGH_PRIORITY issues\n\nüèóÔ∏è **Project Health:**\n- Tests: $([ \"$PROJECT_STABLE\" = true ] && echo \"‚úÖ Stable\" || echo \"‚ùå Unstable\")\n- Build: $([ \"$FRONTEND_STABLE\" = true ] && echo \"‚úÖ Stable\" || echo \"‚ùå Unstable\")\n- Open Issues: $OPEN_ISSUES\n\nüìà **Recent Activity:**\n- Commit: $(git log -1 --oneline)\n- Files Changed: $(echo \"$MODIFIED_FILES\" | wc -l)\n- Areas Affected: Frontend($FRONTEND_CHANGES), Backend($BACKEND_CHANGES), Tests($TEST_CHANGES)\"\n```\n\n## üöÄ **Acciones Autom√°ticas Ejecutadas:**\n\n‚úÖ **Issues cerrados** por palabras clave\n‚úÖ **Epics actualizados** con nuevo progress\n‚úÖ **Milestones asignados** autom√°ticamente\n‚úÖ **Progreso detectado** por contexto\n‚úÖ **Reporte generado** del estado del proyecto\n\n## üí∞ **RESTRICCI√ìN DE PRESUPUESTO: $0.00**

### **Pol√≠tica de Costos:**
```bash\necho \"üí∞ PRESUPUESTO DEL PROYECTO: $0.00\"\necho \"‚úÖ SOLO APIs y servicios GRATUITOS permitidos\"\necho \"‚ùå NO usar servicios de pago bajo ninguna circunstancia\"\n\n# Verificar que todas las APIs sean gratuitas\nverify_free_apis() {\n    local apis_gratuitas=(\n        \"HUGGINGFACE_API_KEY\"    # Hugging Face - GRATIS\n        \"GOOGLE_API_KEY\"         # Google Gemini - GRATIS 60 req/min\n        \"GROQ_API_KEY\"           # Groq - GRATIS 14,400 req/d√≠a\n        \"COHERE_API_KEY\"         # Cohere - GRATIS 100k tokens/mes\n        \"TOGETHER_API_KEY\"       # Together AI - $25 gratis\n        \"REPLICATE_API_TOKEN\"    # Replicate - $10 gratis\n    )\n    \n    echo \"üîç Verificando APIs gratuitas configuradas...\"\n    for api in \"${apis_gratuitas[@]}\"; do\n        if [ -n \"${!api}\" ]; then\n            echo \"‚úÖ $api configurado (GRATIS)\"\n        else\n            echo \"‚ö†Ô∏è $api no configurado - Agregar a tarea 26.1\"\n        fi\n    done\n}\n\n# Verificar hosting gratuito\nverify_free_hosting() {\n    echo \"üè† Verificando opciones de hosting gratuito:\"\n    echo \"‚úÖ GitHub Actions: 2,000 minutos/mes GRATIS\"\n    echo \"‚úÖ Railway.app: $5 USD/mes GRATIS (renovable)\"\n    echo \"‚úÖ Render.com: Plan gratuito disponible\"\n    echo \"‚úÖ Vercel: Plan gratuito para frontend\"\n    echo \"üí∞ Costo total de hosting: $0.00\"\n}\n\n# Ejecutar verificaciones\nverify_free_apis\nverify_free_hosting\n```\n\n### **Recordatorio Autom√°tico:**\n```bash\n# En cada commit, recordar restricci√≥n de presupuesto\necho \"üí∞ RECORDATORIO: Presupuesto del proyecto = $0.00\"\necho \"üÜì Solo usar servicios y APIs completamente gratuitas\"\necho \"üìã Tarea 26: Configurar APIs gratuitas de IA pendiente\"\n\n# Sugerir pr√≥xima tarea gratuita\nsuggest_next_free_task() {\n    echo \"üéØ Pr√≥xima tarea recomendada (GRATIS):\"\n    echo \"26.1 - Registrarse en APIs gratuitas de IA\"\n    echo \"‚Ä¢ Hugging Face: https://huggingface.co/join\"\n    echo \"‚Ä¢ Google Gemini: https://makersuite.google.com/app/apikey\"\n    echo \"‚Ä¢ Groq: https://console.groq.com\"\n    echo \"‚Ä¢ Cohere: https://dashboard.cohere.ai/register\"\n}\n\nsuggest_next_free_task\n```\n\n**¬øContinuar con la gesti√≥n autom√°tica del proyecto (solo opciones gratuitas)?**"
  }
}
